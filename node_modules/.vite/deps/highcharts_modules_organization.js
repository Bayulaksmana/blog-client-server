import {
  __commonJS
} from "./chunk-4MBMRILA.js";

// node_modules/highcharts/modules/organization.js
var require_organization = __commonJS({
  "node_modules/highcharts/modules/organization.js"(exports, module) {
    !/**
    * Highcharts JS v12.3.0 (2025-06-21)
    * Organization chart series type
    * @module highcharts/modules/organization
    * @requires highcharts
    * @requires highcharts/modules/sankey
    *
    * (c) 2019-2025 Torstein Honsi
    *
    * License: www.highcharts.com/license
    */
    function(t, e) {
      "object" == typeof exports && "object" == typeof module ? module.exports = e(t._Highcharts, t._Highcharts.SeriesRegistry, t._Highcharts.SVGElement) : "function" == typeof define && define.amd ? define("highcharts/modules/organization", ["highcharts/highcharts"], function(t2) {
        return e(t2, t2.SeriesRegistry, t2.SVGElement);
      }) : "object" == typeof exports ? exports["highcharts/modules/organization"] = e(t._Highcharts, t._Highcharts.SeriesRegistry, t._Highcharts.SVGElement) : t.Highcharts = e(t.Highcharts, t.Highcharts.SeriesRegistry, t.Highcharts.SVGElement);
    }("undefined" == typeof window ? exports : window, (t, e, i) => (() => {
      "use strict";
      var s = { 28: (t2) => {
        t2.exports = i;
      }, 512: (t2) => {
        t2.exports = e;
      }, 944: (e2) => {
        e2.exports = t;
      } }, n = {};
      function r(t2) {
        var e2 = n[t2];
        if (void 0 !== e2) return e2.exports;
        var i2 = n[t2] = { exports: {} };
        return s[t2](i2, i2.exports, r), i2.exports;
      }
      r.n = (t2) => {
        var e2 = t2 && t2.__esModule ? () => t2.default : () => t2;
        return r.d(e2, { a: e2 }), e2;
      }, r.d = (t2, e2) => {
        for (var i2 in e2) r.o(e2, i2) && !r.o(t2, i2) && Object.defineProperty(t2, i2, { enumerable: true, get: e2[i2] });
      }, r.o = (t2, e2) => Object.prototype.hasOwnProperty.call(t2, e2);
      var o = {};
      r.d(o, { default: () => j });
      var a = r(944), h = r.n(a), l = r(512), d = r.n(l);
      let { sankey: { prototype: { pointClass: p } } } = d().seriesTypes, { defined: g, find: u, pick: c } = h(), f = class extends p {
        constructor(t2, e2, i2) {
          super(t2, e2, i2), this.isNode || (this.dataLabelOnNull = true, this.formatPrefix = "link");
        }
        getSum() {
          return 1;
        }
        setNodeColumn() {
          super.setNodeColumn();
          let t2 = this, e2 = t2.getFromNode().fromNode;
          if (!g(t2.options.column) && 0 !== t2.linksTo.length && e2 && "hanging" === e2.options.layout) {
            let i2 = -1, s2;
            t2.options.layout = c(t2.options.layout, "hanging"), t2.hangsFrom = e2, u(e2.linksFrom, (e3, s3) => {
              let n2 = e3.toNode === t2;
              return n2 && (i2 = s3), n2;
            });
            for (let n2 = 0; n2 < e2.linksFrom.length; ++n2) (s2 = e2.linksFrom[n2]).toNode.id === t2.id ? n2 = e2.linksFrom.length : i2 += function t3(e3) {
              let i3 = e3.linksFrom.length;
              return e3.linksFrom.forEach((e4) => {
                e4.id === e4.toNode.linksTo[0].id ? i3 += t3(e4.toNode) : i3--;
              }), i3;
            }(s2.toNode);
            t2.column = (t2.column || 0) + i2;
          }
        }
      }, y = { applyRadius: function(t2, e2) {
        let i2 = [];
        for (let s2 = 0; s2 < t2.length; s2++) {
          let n2 = t2[s2][1], r2 = t2[s2][2];
          if ("number" == typeof n2 && "number" == typeof r2) if (0 === s2) i2.push(["M", n2, r2]);
          else if (s2 === t2.length - 1) i2.push(["L", n2, r2]);
          else if (e2) {
            let o2 = t2[s2 - 1], a2 = t2[s2 + 1];
            if (o2 && a2) {
              let t3 = o2[1], s3 = o2[2], h2 = a2[1], l2 = a2[2];
              if ("number" == typeof t3 && "number" == typeof h2 && "number" == typeof s3 && "number" == typeof l2 && t3 !== h2 && s3 !== l2) {
                let o3 = t3 < h2 ? 1 : -1, a3 = s3 < l2 ? 1 : -1;
                i2.push(["L", n2 - o3 * Math.min(Math.abs(n2 - t3), e2), r2 - a3 * Math.min(Math.abs(r2 - s3), e2)], ["C", n2, r2, n2, r2, n2 + o3 * Math.min(Math.abs(n2 - h2), e2), r2 + a3 * Math.min(Math.abs(r2 - l2), e2)]);
              }
            }
          } else i2.push(["L", n2, r2]);
        }
        return i2;
      } };
      var m = r(28), k = r.n(m);
      let { deg2rad: x } = h(), { addEvent: b, merge: A, uniqueKey: L, defined: w, extend: v } = h();
      function M(t2, e2) {
        e2 = A(true, { enabled: true, attributes: { dy: -5, startOffset: "50%", textAnchor: "middle" } }, e2);
        let i2 = this.renderer.url, s2 = this.text || this, n2 = s2.textPath, { attributes: r2, enabled: o2 } = e2;
        if (t2 = t2 || n2 && n2.path, n2 && n2.undo(), t2 && o2) {
          let e3 = b(s2, "afterModifyTree", (e4) => {
            if (t2 && o2) {
              let n3 = t2.attr("id");
              n3 || t2.attr("id", n3 = L());
              let o3 = { x: 0, y: 0 };
              w(r2.dx) && (o3.dx = r2.dx, delete r2.dx), w(r2.dy) && (o3.dy = r2.dy, delete r2.dy), s2.attr(o3), this.attr({ transform: "" }), this.box && (this.box = this.box.destroy());
              let a2 = e4.nodes.slice(0);
              e4.nodes.length = 0, e4.nodes[0] = { tagName: "textPath", attributes: v(r2, { "text-anchor": r2.textAnchor, href: `${i2}#${n3}` }), children: a2 };
            }
          });
          s2.textPath = { path: t2, undo: e3 };
        } else s2.attr({ dx: 0, dy: 0 }), delete s2.textPath;
        return this.added && (s2.textCache = "", this.renderer.buildText(s2)), this;
      }
      function N(t2) {
        var _a;
        let e2 = t2.bBox, i2 = (_a = this.element) == null ? void 0 : _a.querySelector("textPath");
        if (i2) {
          let t3 = [], { b: s2, h: n2 } = this.renderer.fontMetrics(this.element), r2 = n2 - s2, o2 = RegExp('(<tspan>|<tspan(?!\\sclass="highcharts-br")[^>]*>|<\\/tspan>)', "g"), a2 = i2.innerHTML.replace(o2, "").split(/<tspan class="highcharts-br"[^>]*>/), h2 = a2.length, l2 = (t4, e3) => {
            let { x: n3, y: o3 } = e3, a3 = (i2.getRotationOfChar(t4) - 90) * x, h3 = Math.cos(a3), l3 = Math.sin(a3);
            return [[n3 - r2 * h3, o3 - r2 * l3], [n3 + s2 * h3, o3 + s2 * l3]];
          };
          for (let e3 = 0, s3 = 0; s3 < h2; s3++) {
            let n3 = a2[s3].length;
            for (let r3 = 0; r3 < n3; r3 += 5) try {
              let n4 = e3 + r3 + s3, [o3, a3] = l2(n4, i2.getStartPositionOfChar(n4));
              0 === r3 ? (t3.push(a3), t3.push(o3)) : (0 === s3 && t3.unshift(a3), s3 === h2 - 1 && t3.push(o3));
            } catch (t4) {
              break;
            }
            e3 += n3 - 1;
            try {
              let n4 = e3 + s3, r3 = i2.getEndPositionOfChar(n4), [o3, a3] = l2(n4, r3);
              t3.unshift(a3), t3.unshift(o3);
            } catch (t4) {
              break;
            }
          }
          t3.length && t3.push(t3[0].slice()), e2.polygon = t3;
        }
        return e2;
      }
      function O(t2) {
        var _a;
        let e2 = t2.labelOptions, i2 = t2.point, s2 = e2[i2.formatPrefix + "TextPath"] || e2.textPath;
        s2 && !e2.useHTML && (this.setTextPath(((_a = i2.getDataLabelPath) == null ? void 0 : _a.call(i2, this)) || i2.graphic, s2), i2.dataLabelPath && !s2.enabled && (i2.dataLabelPath = i2.dataLabelPath.destroy()));
      }
      let { sankey: P } = d().seriesTypes, { css: T, crisp: S, extend: W, isNumber: F, merge: H, pick: C } = h();
      ({ compose: function(t2) {
        b(t2, "afterGetBBox", N), b(t2, "beforeAddingDataLabel", O);
        let e2 = t2.prototype;
        e2.setTextPath || (e2.setTextPath = M);
      } }).compose(k());
      class R extends P {
        alignDataLabel(t2, e2, i2) {
          var _a;
          let s2 = t2.shapeArgs, n2 = e2.text;
          if (i2.useHTML && s2) {
            let t3 = this.options.borderWidth + 2 * this.options.dataLabels.padding, i3 = s2.width || 0, r2 = s2.height || 0;
            this.chart.inverted && (i3 = r2, r2 = s2.width || 0), r2 -= t3, i3 -= t3, (_a = n2.foreignObject) == null ? void 0 : _a.attr({ x: 0, y: 0, width: i3, height: r2 }), T(n2.element.parentNode, { width: i3 + "px", height: r2 + "px" }), T(n2.element, { left: 0, top: 0, width: "100%", height: "100%", overflow: "hidden" }), e2.getBBox = () => ({ width: i3, height: r2, x: 0, y: 0 }), e2.width = i3, e2.height = r2;
          }
          super.alignDataLabel.apply(this, arguments);
        }
        createNode(t2) {
          let e2 = super.createNode.call(this, t2);
          return e2.getSum = () => 1, e2;
        }
        pointAttribs(t2, e2) {
          let i2 = P.prototype.pointAttribs.call(this, t2, e2), s2 = t2.isNode ? t2.level : t2.fromNode.level, n2 = this.mapOptionsToLevel[s2 || 0] || {}, r2 = t2.options, o2 = n2.states && n2.states[e2] || {}, a2 = C(o2.borderRadius, r2.borderRadius, n2.borderRadius, this.options.borderRadius), h2 = C(o2.linkColor, r2.linkColor, n2.linkColor, this.options.linkColor, o2.link && o2.link.color, r2.link && r2.link.color, n2.link && n2.link.color, this.options.link && this.options.link.color), l2 = C(o2.linkLineWidth, r2.linkLineWidth, n2.linkLineWidth, this.options.linkLineWidth, o2.link && o2.link.lineWidth, r2.link && r2.link.lineWidth, n2.link && n2.link.lineWidth, this.options.link && this.options.link.lineWidth), d2 = C(o2.linkOpacity, r2.linkOpacity, n2.linkOpacity, this.options.linkOpacity, o2.link && o2.link.linkOpacity, r2.link && r2.link.linkOpacity, n2.link && n2.link.linkOpacity, this.options.link && this.options.link.linkOpacity);
          return t2.isNode ? F(a2) && (i2.r = a2) : (i2.stroke = h2, i2["stroke-width"] = l2, i2.opacity = d2, delete i2.fill), i2;
        }
        translateLink(t2) {
          let e2 = this.chart, i2 = this.options, s2 = t2.fromNode, n2 = t2.toNode, r2 = C(i2.linkLineWidth, i2.link.lineWidth, 0), o2 = C(i2.link.offset, 0.5), a2 = C(t2.options.link && t2.options.link.type, i2.link.type);
          if (s2.shapeArgs && n2.shapeArgs) {
            let h2 = i2.hangingIndent, l2 = "right" === i2.hangingSide, d2 = n2.options.offset, p2 = /%$/.test(d2) && parseInt(d2, 10), g2 = e2.inverted, u2 = S((s2.shapeArgs.x || 0) + (s2.shapeArgs.width || 0), r2), c2 = S((s2.shapeArgs.y || 0) + (s2.shapeArgs.height || 0) / 2, r2), f2 = S(n2.shapeArgs.x || 0, r2), m2 = S((n2.shapeArgs.y || 0) + (n2.shapeArgs.height || 0) / 2, r2), k2;
            if (g2 && (u2 -= s2.shapeArgs.width || 0, f2 += n2.shapeArgs.width || 0), k2 = this.colDistance ? S(f2 + (g2 ? 1 : -1) * (this.colDistance - this.nodeWidth) / 2, r2) : S((f2 + u2) / 2, r2), p2 && (p2 >= 50 || p2 <= -50) && (k2 = f2 = S(f2 + (g2 ? -0.5 : 0.5) * (n2.shapeArgs.width || 0), r2), m2 = n2.shapeArgs.y || 0, p2 > 0 && (m2 += n2.shapeArgs.height || 0)), n2.hangsFrom === s2 && (e2.inverted ? (c2 = l2 ? S((s2.shapeArgs.y || 0) + h2 / 2, r2) : S((s2.shapeArgs.y || 0) + (s2.shapeArgs.height || 0) - h2 / 2, r2), m2 = l2 ? (n2.shapeArgs.y || 0) + h2 / 2 : (n2.shapeArgs.y || 0) + (n2.shapeArgs.height || 0)) : c2 = S((s2.shapeArgs.y || 0) + h2 / 2, r2), k2 = f2 = S((n2.shapeArgs.x || 0) + (n2.shapeArgs.width || 0) / 2, r2)), t2.plotX = k2, t2.plotY = (c2 + m2) / 2, t2.shapeType = "path", "straight" === a2) t2.shapeArgs = { d: [["M", u2, c2], ["L", f2, m2]] };
            else if ("curved" === a2) {
              let e3 = Math.abs(f2 - u2) * o2 * (g2 ? -1 : 1);
              t2.shapeArgs = { d: [["M", u2, c2], ["C", u2 + e3, c2, f2 - e3, m2, f2, m2]] };
            } else t2.shapeArgs = { d: y.applyRadius([["M", u2, c2], ["L", k2, c2], ["L", k2, m2], ["L", f2, m2]], C(i2.linkRadius, i2.link.radius)) };
            t2.dlBox = { x: (u2 + f2) / 2, y: (c2 + m2) / 2, height: r2, width: 0 };
          }
        }
        translateNode(t2, e2) {
          super.translateNode(t2, e2);
          let i2 = this.chart, s2 = this.options, n2 = Math.max(Math.round(t2.getSum() * this.translationFactor), s2.minLinkWidth || 0), r2 = "right" === s2.hangingSide, o2 = s2.hangingIndent || 0, a2 = s2.hangingIndentTranslation, h2 = s2.minNodeLength || 10, l2 = Math.round(this.nodeWidth), d2 = t2.shapeArgs, p2 = i2.inverted ? -1 : 1, g2 = t2.hangsFrom;
          if (g2) if ("cumulative" === a2) for (d2.height -= o2, i2.inverted && !r2 && (d2.y -= p2 * o2); g2; ) d2.y += (r2 ? 1 : p2) * o2, g2 = g2.hangsFrom;
          else if ("shrink" === a2) for (; g2 && d2.height > o2 + h2; ) d2.height -= o2, (!i2.inverted || r2) && (d2.y += o2), g2 = g2.hangsFrom;
          else d2.height -= o2, (!i2.inverted || r2) && (d2.y += o2);
          t2.nodeHeight = i2.inverted ? d2.width : d2.height, t2.shapeArgs && !t2.hangsFrom && (t2.shapeArgs = H(t2.shapeArgs, { x: (t2.shapeArgs.x || 0) + l2 / 2 - (t2.shapeArgs.width || 0) / 2, y: (t2.shapeArgs.y || 0) + n2 / 2 - (t2.shapeArgs.height || 0) / 2 }));
        }
        drawDataLabels() {
          let t2 = this.options.dataLabels;
          if (t2.linkTextPath && t2.linkTextPath.enabled) for (let t3 of this.points) t3.options.dataLabels = H(t3.options.dataLabels, { useHTML: false });
          super.drawDataLabels();
        }
      }
      R.defaultOptions = H(P.defaultOptions, { borderColor: "#666666", borderRadius: 3, link: { color: "#666666", lineWidth: 1, radius: 10, type: "default" }, borderWidth: 1, dataLabels: { nodeFormatter: function() {
        let t2 = { width: "100%", height: "100%", display: "flex", "flex-direction": "row", "align-items": "center", "justify-content": "center" }, e2 = { "max-height": "100%", "border-radius": "50%" }, i2 = { width: "100%", padding: 0, "text-align": "center", "white-space": "normal" };
        function s2(t3) {
          return Object.keys(t3).reduce(function(e3, i3) {
            return e3 + i3 + ":" + t3[i3] + ";";
          }, 'style="') + '"';
        }
        let { description: n2, image: r2, title: o2 } = this.point;
        r2 && (e2["max-width"] = "30%", i2.width = "70%"), this.series.chart.renderer.forExport && (t2.display = "block", i2.position = "absolute", i2.left = r2 ? "30%" : 0, i2.top = 0);
        let a2 = "<div " + s2(t2) + ">";
        return r2 && (a2 += '<img src="' + r2 + '" ' + s2(e2) + ">"), a2 += "<div " + s2(i2) + ">", this.point.name && (a2 += "<h4 " + s2({ margin: 0 }) + ">" + this.point.name + "</h4>"), o2 && (a2 += "<p " + s2({ margin: 0 }) + ">" + (o2 || "") + "</p>"), n2 && (a2 += "<p " + s2({ opacity: 0.75, margin: "5px" }) + ">" + n2 + "</p>"), a2 += "</div></div>";
      }, style: { fontWeight: "normal", fontSize: "0.9em", textAlign: "left" }, useHTML: true, linkTextPath: { attributes: { startOffset: "95%", textAnchor: "end" } } }, hangingIndent: 20, hangingIndentTranslation: "inherit", hangingSide: "left", minNodeLength: 10, nodeWidth: 50, tooltip: { nodeFormat: "{point.name}<br>{point.title}<br>{point.description}" } }), W(R.prototype, { pointClass: f }), d().registerSeriesType("organization", R);
      let j = h();
      return o.default;
    })());
  }
});
export default require_organization();
//# sourceMappingURL=highcharts_modules_organization.js.map
