import {
  __commonJS
} from "./chunk-4MBMRILA.js";

// node_modules/highcharts/modules/sankey.js
var require_sankey = __commonJS({
  "node_modules/highcharts/modules/sankey.js"(exports, module) {
    !/**
    * Highcharts JS v12.3.0 (2025-06-21)
    * @module highcharts/modules/sankey
    * @requires highcharts
    *
    * Sankey diagram module
    *
    * (c) 2010-2025 Torstein Honsi
    *
    * License: www.highcharts.com/license
    */
    function(t, e) {
      "object" == typeof exports && "object" == typeof module ? module.exports = e(t._Highcharts, t._Highcharts.SeriesRegistry, t._Highcharts.Point, t._Highcharts.Color, t._Highcharts.SVGElement) : "function" == typeof define && define.amd ? define("highcharts/modules/sankey", ["highcharts/highcharts"], function(t2) {
        return e(t2, t2.SeriesRegistry, t2.Point, t2.Color, t2.SVGElement);
      }) : "object" == typeof exports ? exports["highcharts/modules/sankey"] = e(t._Highcharts, t._Highcharts.SeriesRegistry, t._Highcharts.Point, t._Highcharts.Color, t._Highcharts.SVGElement) : t.Highcharts = e(t.Highcharts, t.Highcharts.SeriesRegistry, t.Highcharts.Point, t.Highcharts.Color, t.Highcharts.SVGElement);
    }("undefined" == typeof window ? exports : window, (t, e, o, i, s) => (() => {
      "use strict";
      var n, r, l = { 28: (t2) => {
        t2.exports = s;
      }, 260: (t2) => {
        t2.exports = o;
      }, 512: (t2) => {
        t2.exports = e;
      }, 620: (t2) => {
        t2.exports = i;
      }, 944: (e2) => {
        e2.exports = t;
      } }, a = {};
      function h(t2) {
        var e2 = a[t2];
        if (void 0 !== e2) return e2.exports;
        var o2 = a[t2] = { exports: {} };
        return l[t2](o2, o2.exports, h), o2.exports;
      }
      h.n = (t2) => {
        var e2 = t2 && t2.__esModule ? () => t2.default : () => t2;
        return h.d(e2, { a: e2 }), e2;
      }, h.d = (t2, e2) => {
        for (var o2 in e2) h.o(e2, o2) && !h.o(t2, o2) && Object.defineProperty(t2, o2, { enumerable: true, get: e2[o2] });
      }, h.o = (t2, e2) => Object.prototype.hasOwnProperty.call(t2, e2);
      var d = {};
      h.d(d, { default: () => tc });
      var p = h(944), c = h.n(p), u = h(512), f = h.n(u);
      let { series: { prototype: m, prototype: { pointClass: { prototype: g } } } } = f(), { defined: y, extend: x, find: b, merge: v, pick: k } = c();
      !function(t2) {
        function e2() {
          return this.data = [].concat(this.points || [], this.nodes), m.destroy.apply(this, arguments);
        }
        function o2() {
          this.nodes && (this.nodes.forEach((t3) => {
            t3.destroy();
          }), this.nodes.length = 0), m.setData.apply(this, arguments);
        }
        function i2(t3) {
          let e3 = arguments, o3 = this.isNode ? this.linksTo.concat(this.linksFrom) : [this.fromNode, this.toNode];
          "select" !== t3 && o3.forEach((t4) => {
            t4 && t4.series && (g.setState.apply(t4, e3), !t4.isNode && (t4.fromNode.graphic && g.setState.apply(t4.fromNode, e3), t4.toNode && t4.toNode.graphic && g.setState.apply(t4.toNode, e3)));
          }), g.setState.apply(this, e3);
        }
        function s2(t3, e3, o3, i3) {
          let s3 = this.series.options.nodes, n2 = this.series.options.data, r2 = (n2 == null ? void 0 : n2.length) || 0, l2 = n2 == null ? void 0 : n2[this.index];
          if (g.update.call(this, t3, !this.isNode && e3, o3, i3), this.isNode) {
            let t4 = (s3 || []).reduce((t5, e4, o4) => this.id === e4.id ? o4 : t5, -1), i4 = v(s3 && s3[t4] || {}, (n2 == null ? void 0 : n2[this.index]) || {});
            n2 && (l2 ? n2[this.index] = l2 : n2.length = r2), s3 ? t4 >= 0 ? s3[t4] = i4 : s3.push(i4) : this.series.options.nodes = [i4], k(e3, true) && this.series.chart.redraw(o3);
          }
        }
        t2.compose = function(t3, n2) {
          let r2 = t3.prototype, l2 = n2.prototype;
          return r2.setNodeState = i2, r2.setState = i2, r2.update = s2, l2.destroy = e2, l2.setData = o2, n2;
        }, t2.createNode = function(t3) {
          let e3 = this.pointClass, o3 = (t4, e4) => b(t4, (t5) => t5.id === e4), i3 = o3(this.nodes, t3), s3;
          if (!i3) {
            s3 = this.options.nodes && o3(this.options.nodes, t3);
            let n2 = new e3(this, x({ className: "highcharts-node", isNode: true, id: t3, y: 1 }, s3));
            n2.linksTo = [], n2.linksFrom = [], n2.getSum = function() {
              let t4 = 0, e4 = 0;
              return n2.linksTo.forEach((e5) => {
                t4 += e5.weight || 0;
              }), n2.linksFrom.forEach((t5) => {
                e4 += t5.weight || 0;
              }), Math.max(t4, e4);
            }, n2.offset = function(t4, e4) {
              let o4 = 0;
              for (let i4 = 0; i4 < n2[e4].length; i4++) {
                if (n2[e4][i4] === t4) return o4;
                o4 += n2[e4][i4].weight;
              }
            }, n2.hasShape = function() {
              let t4 = 0;
              return n2.linksTo.forEach((e4) => {
                e4.outgoing && t4++;
              }), !n2.linksTo.length || t4 !== n2.linksTo.length;
            }, n2.index = this.nodes.push(n2) - 1, i3 = n2;
          }
          return i3.formatPrefix = "node", i3.name = i3.name || i3.options.id || "", i3.mass = k(i3.options.mass, i3.options.marker && i3.options.marker.radius, this.options.marker && this.options.marker.radius, 4), i3;
        }, t2.destroy = e2, t2.generatePoints = function() {
          let t3 = this.chart, e3 = {};
          m.generatePoints.call(this), this.nodes || (this.nodes = []), this.colorCounter = 0, this.nodes.forEach((t4) => {
            t4.linksFrom.length = 0, t4.linksTo.length = 0, t4.level = t4.options.level;
          }), this.points.forEach((o3) => {
            y(o3.from) && (e3[o3.from] || (e3[o3.from] = this.createNode(o3.from)), e3[o3.from].linksFrom.push(o3), o3.fromNode = e3[o3.from], t3.styledMode ? o3.colorIndex = k(o3.options.colorIndex, e3[o3.from].colorIndex) : o3.color = o3.options.color || e3[o3.from].color), y(o3.to) && (e3[o3.to] || (e3[o3.to] = this.createNode(o3.to)), e3[o3.to].linksTo.push(o3), o3.toNode = e3[o3.to]), o3.name = o3.name || o3.id;
          }, this), this.nodeLookup = e3;
        }, t2.setNodeState = i2, t2.updateNode = s2;
      }(n || (n = {}));
      let C = n;
      var N = h(260), P = h.n(N);
      let { column: L } = f().seriesTypes, { defined: S } = c();
      class T extends L.prototype.pointClass {
        applyOptions(t2, e2) {
          return P().prototype.applyOptions.call(this, t2, e2), S(this.options.level) && (this.options.column = this.column = this.options.level), this;
        }
        getClassName() {
          return (this.isNode ? "highcharts-node " : "highcharts-link ") + P().prototype.getClassName.call(this);
        }
        getFromNode() {
          let t2 = -1, e2;
          for (let o2 = 0; o2 < this.linksTo.length; o2++) {
            let i2 = this.linksTo[o2];
            i2.fromNode.column > t2 && i2.fromNode !== this && (t2 = (e2 = i2.fromNode).column);
          }
          return { fromNode: e2, fromColumn: t2 };
        }
        setNodeColumn() {
          S(this.options.column) || (0 === this.linksTo.length ? this.column = 0 : this.column = this.getFromNode().fromColumn + 1);
        }
        isValid() {
          return this.isNode || "number" == typeof this.weight;
        }
      }
      let { defined: w, getAlignFactor: O, relativeLength: M } = c();
      !function(t2) {
        t2.compose = function(t3, o2) {
          return t3.sankeyColumn = new e2(t3, o2), t3;
        };
        class e2 {
          constructor(t3, e3) {
            this.points = t3, this.series = e3;
          }
          getTranslationFactor(t3) {
            let e3 = this.points, o2 = e3.slice(), i2 = t3.chart, s2 = t3.options.minLinkWidth || 0, n2, r2 = 0, l2, a2 = (i2.plotSizeY || 0) - (t3.options.borderWidth || 0) - (e3.length - 1) * t3.nodePadding;
            for (; e3.length; ) {
              for (r2 = a2 / e3.sankeyColumn.sum(), n2 = false, l2 = e3.length; l2--; ) e3[l2].getSum() * r2 < s2 && (e3.splice(l2, 1), a2 = Math.max(0, a2 - s2), n2 = true);
              if (!n2) break;
            }
            for (let t4 of (e3.length = 0, o2)) e3.push(t4);
            return r2;
          }
          top(t3) {
            let e3 = this.series, o2 = e3.nodePadding, i2 = this.points.reduce((i3, s2) => (i3 > 0 && (i3 += o2), i3 += Math.max(s2.getSum() * t3, e3.options.minLinkWidth || 0)), 0);
            return O(e3.options.nodeAlignment || "center") * ((e3.chart.plotSizeY || 0) - i2);
          }
          left(t3) {
            let e3 = this.series, o2 = e3.chart, i2 = e3.options.equalNodes, s2 = o2.inverted ? o2.plotHeight : o2.plotWidth, n2 = e3.nodePadding, r2 = this.points.reduce((o3, r3) => (o3 > 0 && (o3 += n2), o3 += i2 ? s2 / r3.series.nodes.length - n2 : Math.max(r3.getSum() * t3, e3.options.minLinkWidth || 0)), 0);
            return ((o2.plotSizeX || 0) - Math.round(r2)) / 2;
          }
          sum() {
            return this.points.reduce((t3, e3) => t3 + e3.getSum(), 0);
          }
          offset(t3, e3) {
            let o2 = this.points, i2 = this.series, s2 = i2.nodePadding, n2 = 0, r2;
            if (i2.is("organization") && t3.hangsFrom) return { absoluteTop: t3.hangsFrom.nodeY };
            for (let l2 = 0; l2 < o2.length; l2++) {
              let a2 = o2[l2].getSum(), h2 = Math.max(a2 * e3, i2.options.minLinkWidth || 0), d2 = t3.options[i2.chart.inverted ? "offsetHorizontal" : "offsetVertical"], p2 = t3.options.offset || 0;
              if (r2 = a2 ? h2 + s2 : 0, o2[l2] === t3) return { relativeTop: n2 + (w(d2) ? M(d2, h2) : M(p2, r2)) };
              n2 += r2;
            }
          }
        }
        t2.SankeyColumnAdditions = e2;
      }(r || (r = {}));
      let F = r;
      var W = h(620), H = h.n(W);
      let { extend: z, isArray: I, isNumber: D, isObject: B, merge: Y, pick: E, relativeLength: A } = c();
      var _ = h(28), R = h.n(_);
      let { deg2rad: X } = c(), { addEvent: V, merge: j, uniqueKey: G, defined: $, extend: q } = c();
      function Z(t2, e2) {
        e2 = j(true, { enabled: true, attributes: { dy: -5, startOffset: "50%", textAnchor: "middle" } }, e2);
        let o2 = this.renderer.url, i2 = this.text || this, s2 = i2.textPath, { attributes: n2, enabled: r2 } = e2;
        if (t2 = t2 || s2 && s2.path, s2 && s2.undo(), t2 && r2) {
          let e3 = V(i2, "afterModifyTree", (e4) => {
            if (t2 && r2) {
              let s3 = t2.attr("id");
              s3 || t2.attr("id", s3 = G());
              let r3 = { x: 0, y: 0 };
              $(n2.dx) && (r3.dx = n2.dx, delete n2.dx), $(n2.dy) && (r3.dy = n2.dy, delete n2.dy), i2.attr(r3), this.attr({ transform: "" }), this.box && (this.box = this.box.destroy());
              let l2 = e4.nodes.slice(0);
              e4.nodes.length = 0, e4.nodes[0] = { tagName: "textPath", attributes: q(n2, { "text-anchor": n2.textAnchor, href: `${o2}#${s3}` }), children: l2 };
            }
          });
          i2.textPath = { path: t2, undo: e3 };
        } else i2.attr({ dx: 0, dy: 0 }), delete i2.textPath;
        return this.added && (i2.textCache = "", this.renderer.buildText(i2)), this;
      }
      function J(t2) {
        var _a;
        let e2 = t2.bBox, o2 = (_a = this.element) == null ? void 0 : _a.querySelector("textPath");
        if (o2) {
          let t3 = [], { b: i2, h: s2 } = this.renderer.fontMetrics(this.element), n2 = s2 - i2, r2 = RegExp('(<tspan>|<tspan(?!\\sclass="highcharts-br")[^>]*>|<\\/tspan>)', "g"), l2 = o2.innerHTML.replace(r2, "").split(/<tspan class="highcharts-br"[^>]*>/), a2 = l2.length, h2 = (t4, e3) => {
            let { x: s3, y: r3 } = e3, l3 = (o2.getRotationOfChar(t4) - 90) * X, a3 = Math.cos(l3), h3 = Math.sin(l3);
            return [[s3 - n2 * a3, r3 - n2 * h3], [s3 + i2 * a3, r3 + i2 * h3]];
          };
          for (let e3 = 0, i3 = 0; i3 < a2; i3++) {
            let s3 = l2[i3].length;
            for (let n3 = 0; n3 < s3; n3 += 5) try {
              let s4 = e3 + n3 + i3, [r3, l3] = h2(s4, o2.getStartPositionOfChar(s4));
              0 === n3 ? (t3.push(l3), t3.push(r3)) : (0 === i3 && t3.unshift(l3), i3 === a2 - 1 && t3.push(r3));
            } catch (t4) {
              break;
            }
            e3 += s3 - 1;
            try {
              let s4 = e3 + i3, n3 = o2.getEndPositionOfChar(s4), [r3, l3] = h2(s4, n3);
              t3.unshift(l3), t3.unshift(r3);
            } catch (t4) {
              break;
            }
          }
          t3.length && t3.push(t3[0].slice()), e2.polygon = t3;
        }
        return e2;
      }
      function K(t2) {
        var _a;
        let e2 = t2.labelOptions, o2 = t2.point, i2 = e2[o2.formatPrefix + "TextPath"] || e2.textPath;
        i2 && !e2.useHTML && (this.setTextPath(((_a = o2.getDataLabelPath) == null ? void 0 : _a.call(o2, this)) || o2.graphic, i2), o2.dataLabelPath && !i2.enabled && (o2.dataLabelPath = o2.dataLabelPath.destroy()));
      }
      let { column: Q, line: U } = f().seriesTypes, { parse: tt } = H(), { getLevelOptions: te, getNodeWidth: to } = { getColor: function(t2, e2) {
        let o2, i2, s2, n2, r2, l2, a2 = e2.index, h2 = e2.mapOptionsToLevel, d2 = e2.parentColor, p2 = e2.parentColorIndex, c2 = e2.series, u2 = e2.colors, f2 = e2.siblings, m2 = c2.points, g2 = c2.chart.options.chart;
        return t2 && (o2 = m2[t2.i], i2 = h2[t2.level] || {}, o2 && i2.colorByPoint && (n2 = o2.index % (u2 ? u2.length : g2.colorCount), s2 = u2 && u2[n2]), c2.chart.styledMode || (r2 = E(o2 && o2.options.color, i2 && i2.color, s2, d2 && ((t3) => {
          let e3 = i2 && i2.colorVariation;
          return e3 && "brightness" === e3.key && a2 && f2 ? H().parse(t3).brighten(e3.to * (a2 / f2)).get() : t3;
        })(d2), c2.color)), l2 = E(o2 && o2.options.colorIndex, i2 && i2.colorIndex, n2, p2, e2.colorIndex)), { color: r2, colorIndex: l2 };
      }, getLevelOptions: function(t2) {
        let e2, o2, i2, s2, n2, r2, l2 = {};
        if (B(t2)) for (s2 = D(t2.from) ? t2.from : 1, r2 = t2.levels, o2 = {}, e2 = B(t2.defaults) ? t2.defaults : {}, I(r2) && (o2 = r2.reduce((t3, o3) => {
          let i3, n3, r3;
          return B(o3) && D(o3.level) && (n3 = E((r3 = Y({}, o3)).levelIsConstant, e2.levelIsConstant), delete r3.levelIsConstant, delete r3.level, B(t3[i3 = o3.level + (n3 ? 0 : s2 - 1)]) ? Y(true, t3[i3], r3) : t3[i3] = r3), t3;
        }, {})), n2 = D(t2.to) ? t2.to : 1, i2 = 0; i2 <= n2; i2++) l2[i2] = Y({}, e2, B(o2[i2]) ? o2[i2] : {});
        return l2;
      }, getNodeWidth: function(t2, e2) {
        let { chart: o2, options: i2 } = t2, { nodeDistance: s2 = 0, nodeWidth: n2 = 0 } = i2, { plotSizeX: r2 = 1 } = o2;
        if ("auto" === n2) {
          if ("string" == typeof s2 && /%$/.test(s2)) return r2 / (e2 + parseFloat(s2) / 100 * (e2 - 1));
          let t3 = Number(s2);
          return (r2 + t3) / (e2 || 1) - t3;
        }
        return A(n2, r2);
      }, setTreeValues: function t2(e2, o2) {
        let i2 = o2.before, s2 = o2.idRoot, n2 = o2.mapIdToNode[s2], r2 = false !== o2.levelIsConstant, l2 = o2.points[e2.i], a2 = l2 && l2.options || {}, h2 = [], d2 = 0;
        e2.levelDynamic = e2.level - (r2 ? 0 : n2.level), e2.name = E(l2 && l2.name, ""), e2.visible = s2 === e2.id || true === o2.visible, "function" == typeof i2 && (e2 = i2(e2, o2)), e2.children.forEach((i3, s3) => {
          let n3 = z({}, o2);
          z(n3, { index: s3, siblings: e2.children.length, visible: e2.visible }), i3 = t2(i3, n3), h2.push(i3), i3.visible && (d2 += i3.val);
        });
        let p2 = E(a2.value, d2);
        return e2.visible = p2 >= 0 && (d2 > 0 || e2.visible), e2.children = h2, e2.childrenTotal = d2, e2.isLeaf = e2.visible && !d2, e2.val = p2, e2;
      }, updateRootId: function(t2) {
        let e2, o2;
        return B(t2) && (o2 = B(t2.options) ? t2.options : {}, e2 = E(t2.rootNode, o2.rootId, ""), B(t2.userOptions) && (t2.userOptions.rootId = e2), t2.rootNode = e2), e2;
      } }, { clamp: ti, crisp: ts, extend: tn, isObject: tr, merge: tl, pick: ta, relativeLength: th, stableSort: td } = c();
      ({ compose: function(t2) {
        V(t2, "afterGetBBox", J), V(t2, "beforeAddingDataLabel", K);
        let e2 = t2.prototype;
        e2.setTextPath || (e2.setTextPath = Z);
      } }).compose(R());
      class tp extends Q {
        static getDLOptions(t2) {
          let e2 = tr(t2.optionsPoint) ? t2.optionsPoint.dataLabels : {};
          return tl({ style: {} }, tr(t2.level) ? t2.level.dataLabels : {}, e2);
        }
        createNodeColumns() {
          let t2 = [];
          for (let e2 of this.nodes) e2.setNodeColumn(), t2[e2.column] || (t2[e2.column] = F.compose([], this)), t2[e2.column].push(e2);
          for (let e2 = 0; e2 < t2.length; e2++) void 0 === t2[e2] && (t2[e2] = F.compose([], this));
          return t2;
        }
        order(t2, e2) {
          if (void 0 === t2.level) for (let o2 of (t2.level = e2, t2.linksFrom)) o2.toNode && this.order(o2.toNode, e2 + 1);
        }
        generatePoints() {
          if (C.generatePoints.apply(this, arguments), this.orderNodes) {
            for (let t2 of this.nodes) 0 === t2.linksTo.length && this.order(t2, 0);
            td(this.nodes, (t2, e2) => t2.level - e2.level);
          }
        }
        getNodePadding() {
          let t2 = this.options.nodePadding || 0;
          if (this.nodeColumns) {
            let e2 = this.nodeColumns.reduce((t3, e3) => Math.max(t3, e3.length), 0);
            e2 * t2 > this.chart.plotSizeY && (t2 = this.chart.plotSizeY / e2);
          }
          return t2;
        }
        hasData() {
          return !!this.dataTable.rowCount;
        }
        pointAttribs(t2, e2) {
          if (!t2) return {};
          let o2 = this, i2 = t2.isNode ? t2.level : t2.fromNode.level, s2 = o2.mapOptionsToLevel[i2 || 0] || {}, n2 = t2.options, r2 = s2.states && s2.states[e2 || ""] || {}, l2 = ["colorByPoint", "borderColor", "borderWidth", "linkOpacity", "opacity"].reduce((t3, e3) => (t3[e3] = ta(r2[e3], n2[e3], s2[e3], o2.options[e3]), t3), {}), a2 = ta(r2.color, n2.color, l2.colorByPoint ? t2.color : s2.color);
          return t2.isNode ? { fill: a2, stroke: l2.borderColor, "stroke-width": l2.borderWidth, opacity: l2.opacity } : { fill: a2, "fill-opacity": l2.linkOpacity };
        }
        drawTracker() {
          Q.prototype.drawTracker.call(this, this.points), Q.prototype.drawTracker.call(this, this.nodes);
        }
        drawPoints() {
          Q.prototype.drawPoints.call(this, this.points), Q.prototype.drawPoints.call(this, this.nodes);
        }
        drawDataLabels() {
          Q.prototype.drawDataLabels.call(this, this.points), Q.prototype.drawDataLabels.call(this, this.nodes);
        }
        translate() {
          this.generatePoints(), this.nodeColumns = this.createNodeColumns();
          let t2 = this, e2 = this.chart, o2 = this.options, i2 = this.nodeColumns, s2 = i2.length;
          for (let n2 of (this.nodeWidth = to(this, s2), this.nodePadding = this.getNodePadding(), this.translationFactor = i2.reduce((e3, o3) => Math.min(e3, o3.sankeyColumn.getTranslationFactor(t2)), 1 / 0), this.colDistance = (e2.plotSizeX - this.nodeWidth - o2.borderWidth) / Math.max(1, i2.length - 1), t2.mapOptionsToLevel = te({ from: 1, levels: o2.levels, to: i2.length - 1, defaults: { borderColor: o2.borderColor, borderRadius: o2.borderRadius, borderWidth: o2.borderWidth, color: t2.color, colorByPoint: o2.colorByPoint, levelIsConstant: true, linkColor: o2.linkColor, linkLineWidth: o2.linkLineWidth, linkOpacity: o2.linkOpacity, states: o2.states } }), i2)) for (let e3 of n2) t2.translateNode(e3, n2);
          for (let e3 of this.nodes) for (let o3 of e3.linksFrom) (o3.weight || o3.isNull) && o3.to && (t2.translateLink(o3), o3.allowShadow = false);
        }
        translateLink(t2) {
          let e2 = (e3, o3) => {
            let i3 = e3.offset(t2, o3) * r2;
            return Math.min(e3.nodeY + i3, e3.nodeY + (e3.shapeArgs && e3.shapeArgs.height || 0) - u2);
          }, o2 = t2.fromNode, i2 = t2.toNode, s2 = this.chart, { inverted: n2 } = s2, r2 = this.translationFactor, l2 = this.options, a2 = ta(t2.linkColorMode, l2.linkColorMode), h2 = (s2.inverted ? -this.colDistance : this.colDistance) * l2.curveFactor, d2 = o2.nodeX, p2 = i2.nodeX, c2 = t2.outgoing, u2 = Math.max(t2.weight * r2, this.options.minLinkWidth), f2 = e2(o2, "linksFrom"), m2 = e2(i2, "linksTo"), g2 = this.nodeWidth, y2 = p2 > d2 + g2;
          if (s2.inverted && (f2 = s2.plotSizeY - f2, m2 = (s2.plotSizeY || 0) - m2, g2 = -g2, u2 = -u2, y2 = d2 > p2), t2.shapeType = "path", t2.linkBase = [f2, f2 + u2, m2, m2 + u2], y2 && "number" == typeof m2) t2.shapeArgs = { d: [["M", d2 + g2, f2], ["C", d2 + g2 + h2, f2, p2 - h2, m2, p2, m2], ["L", p2 + (c2 ? g2 : 0), m2 + u2 / 2], ["L", p2, m2 + u2], ["C", p2 - h2, m2 + u2, d2 + g2 + h2, f2 + u2, d2 + g2, f2 + u2], ["Z"]] };
          else if ("number" == typeof m2) {
            let e3 = s2.plotHeight - f2 - u2, o3 = p2 - 20 - u2, i3 = p2 - 20, n3 = d2 + g2, r3 = n3 + 20, l3 = r3 + u2, a3 = f2, h3 = f2 + u2, c3 = h3 + 20, y3 = c3 + e3, x2 = y3 + 20, b2 = x2 + u2, v2 = m2, k2 = v2 + u2, C2 = k2 + 20, N2 = h3 - 0.7 * u2, P2 = x2 + 0.7 * u2, L2 = k2 - 0.7 * u2, S2 = p2 - 0.7 * u2, T2 = n3 + 0.7 * u2;
            t2.shapeArgs = { d: [["M", n3, a3], ["C", T2, a3, l3, N2, l3, c3], ["L", l3, y3], ["C", l3, P2, T2, b2, n3, b2], ["L", p2, b2], ["C", S2, b2, o3, P2, o3, y3], ["L", o3, C2], ["C", o3, L2, S2, v2, p2, v2], ["L", p2, k2], ["C", i3, k2, i3, k2, i3, C2], ["L", i3, y3], ["C", i3, x2, i3, x2, p2, x2], ["L", n3, x2], ["C", r3, x2, r3, x2, r3, y3], ["L", r3, c3], ["C", r3, h3, r3, h3, n3, h3], ["Z"]] };
          }
          if (t2.dlBox = { x: d2 + (p2 - d2 + g2) / 2, y: f2 + (m2 - f2) / 2, height: u2, width: 0 }, t2.tooltipPos = s2.inverted ? [s2.plotSizeY - t2.dlBox.y - u2 / 2, s2.plotSizeX - t2.dlBox.x] : [t2.dlBox.x, t2.dlBox.y + u2 / 2], t2.y = t2.plotY = 1, t2.x = t2.plotX = 1, !t2.options.color) {
            if ("from" === a2) t2.color = o2.color;
            else if ("to" === a2) t2.color = i2.color;
            else if ("gradient" === a2) {
              let e3 = tt(o2.color).get(), s3 = tt(i2.color).get();
              t2.color = { linearGradient: { x1: 1, x2: 0, y1: 0, y2: 0 }, stops: [[0, n2 ? e3 : s3], [1, n2 ? s3 : e3]] };
            }
          }
        }
        translateNode(t2, e2) {
          let o2 = this.translationFactor, i2 = this.chart, s2 = this.options, { borderRadius: n2, borderWidth: r2 = 0 } = s2, l2 = t2.getSum(), a2 = Math.max(Math.round(l2 * o2), this.options.minLinkWidth), h2 = Math.round(this.nodeWidth), d2 = e2.sankeyColumn.offset(t2, o2), p2 = ts(ta(d2.absoluteTop, e2.sankeyColumn.top(o2) + d2.relativeTop), r2), c2 = ts(this.colDistance * t2.column + r2 / 2, r2) + th(t2.options[i2.inverted ? "offsetVertical" : "offsetHorizontal"] || 0, h2), u2 = i2.inverted ? i2.plotSizeX - c2 : c2;
          if (t2.sum = l2, l2) {
            t2.shapeType = "roundedRect", t2.nodeX = u2, t2.nodeY = p2;
            let e3 = u2, o3 = p2, r3 = t2.options.width || s2.width || h2, l3 = t2.options.height || s2.height || a2, d3 = ti(th("object" == typeof n2 ? n2.radius : n2 || 0, r3), 0, a2 / 2);
            i2.inverted && (e3 = u2 - h2, o3 = i2.plotSizeY - p2 - a2, r3 = t2.options.height || s2.height || h2, l3 = t2.options.width || s2.width || a2), t2.dlOptions = tp.getDLOptions({ level: this.mapOptionsToLevel[t2.level], optionsPoint: t2.options }), t2.plotX = 1, t2.plotY = 1, t2.tooltipPos = i2.inverted ? [i2.plotSizeY - o3 - l3 / 2, i2.plotSizeX - e3 - r3 / 2] : [e3 + r3 / 2, o3 + l3 / 2], t2.shapeArgs = { x: e3, y: o3, width: r3, height: l3, r: d3, display: t2.hasShape() ? "" : "none" };
          } else t2.dlOptions = { enabled: false };
        }
      }
      tp.defaultOptions = tl(Q.defaultOptions, { borderWidth: 0, colorByPoint: true, curveFactor: 0.33, dataLabels: { enabled: true, backgroundColor: "none", crop: false, nodeFormat: void 0, nodeFormatter: function() {
        return this.point.name;
      }, format: void 0, formatter: function() {
      }, inside: true }, inactiveOtherPoints: true, linkColorMode: "from", linkOpacity: 0.5, opacity: 1, minLinkWidth: 0, nodeAlignment: "center", nodeWidth: 20, nodePadding: 10, nodeDistance: 30, showInLegend: false, states: { hover: { linkOpacity: 1, opacity: 1 }, inactive: { linkOpacity: 0.1, opacity: 0.1, animation: { duration: 50 } } }, tooltip: { followPointer: true, headerFormat: '<span style="font-size: 0.8em">{series.name}</span><br/>', pointFormat: "{point.fromNode.name} â†’ {point.toNode.name}: <b>{point.weight}</b><br/>", nodeFormat: "{point.name}: <b>{point.sum}</b><br/>" } }), C.compose(T, tp), tn(tp.prototype, { animate: U.prototype.animate, createNode: C.createNode, forceDL: true, invertible: true, isCartesian: false, orderNodes: true, noSharedTooltip: true, pointArrayMap: ["from", "to", "weight"], pointClass: T, searchPoint: c().noop }), f().registerSeriesType("sankey", tp);
      let tc = c();
      return d.default;
    })());
  }
});
export default require_sankey();
//# sourceMappingURL=highcharts_modules_sankey.js.map
